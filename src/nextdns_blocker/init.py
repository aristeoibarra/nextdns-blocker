"""Interactive initialization wizard for NextDNS Blocker."""

import logging
import os
import subprocess
from pathlib import Path
from typing import Optional
from zoneinfo import ZoneInfo

import click
import requests

from .common import get_log_dir, write_secure_file
from .completion import detect_shell, install_completion
from .config import DEFAULT_TIMEOUT, get_config_dir
from .platform_utils import (
    get_executable_args,
    has_systemd,
    is_macos,
    is_windows,
)

logger = logging.getLogger(__name__)

# Timeout for subprocess commands during init (seconds)
INIT_SUBPROCESS_TIMEOUT = 30

# NextDNS API base URL for validation
NEXTDNS_API_URL = "https://api.nextdns.io"


def validate_api_credentials(api_key: str, profile_id: str) -> tuple[bool, str]:
    """
    Validate API credentials against NextDNS API.

    Args:
        api_key: NextDNS API key
        profile_id: NextDNS profile ID

    Returns:
        Tuple of (success, message)
    """
    try:
        response = requests.get(
            f"{NEXTDNS_API_URL}/profiles/{profile_id}/denylist",
            headers={"X-Api-Key": api_key},
            timeout=DEFAULT_TIMEOUT,
        )

        if response.status_code == 200:
            return True, "Credentials valid"
        elif response.status_code == 401:
            return False, "Invalid API key"
        elif response.status_code == 404:
            return False, "Profile ID not found"
        else:
            return False, f"API error: {response.status_code}"

    except requests.exceptions.Timeout:
        return False, "Connection timeout"
    except requests.exceptions.ConnectionError:
        return False, "Connection failed"
    except requests.exceptions.RequestException as e:
        return False, f"Request error: {e}"


def validate_timezone(tz_str: str) -> tuple[bool, str]:
    """
    Validate a timezone string.

    Args:
        tz_str: Timezone string (e.g., 'America/Mexico_City')

    Returns:
        Tuple of (success, message)
    """
    try:
        ZoneInfo(tz_str)
        return True, "Valid timezone"
    except KeyError:
        return False, f"Invalid timezone: {tz_str}"


def detect_system_timezone() -> str:
    """
    Auto-detect the system timezone.

    Attempts detection in order:
    1. TZ environment variable
    2. tzlocal library (cross-platform, handles all Windows timezones)
    3. /etc/localtime symlink (macOS/Linux fallback)
    4. Falls back to UTC

    Returns:
        IANA timezone string (e.g., 'America/Mexico_City')
    """
    # Try TZ environment variable first
    tz_env = os.environ.get("TZ")
    if tz_env:
        try:
            ZoneInfo(tz_env)
            return tz_env
        except KeyError:
            logger.debug(f"TZ environment variable '{tz_env}' is not a valid timezone")

    # Try tzlocal library (cross-platform, handles all Windows timezones)
    try:
        from tzlocal import get_localzone

        tz = get_localzone()
        tz_name = str(tz)
        # Validate the timezone name
        try:
            ZoneInfo(tz_name)
            return tz_name
        except KeyError:
            logger.debug(f"tzlocal returned invalid timezone: {tz_name}")
    except ImportError:
        logger.debug("tzlocal library not available")
    except Exception as e:
        logger.debug(f"tzlocal detection failed: {e}")

    # Fallback: Try reading /etc/localtime symlink (macOS/Linux)
    if not is_windows():
        try:
            localtime = Path("/etc/localtime")
            if localtime.is_symlink():
                target = str(localtime.resolve())
                # Handle both "zoneinfo/" and "zoneinfo.default/" (macOS)
                for marker in ("zoneinfo/", "zoneinfo.default/"):
                    if marker in target:
                        tz_name = target.split(marker)[-1]
                        try:
                            ZoneInfo(tz_name)
                            return tz_name
                        except KeyError:
                            logger.debug(f"Timezone '{tz_name}' from /etc/localtime is not valid")
                            # Continue to try next marker or fallback
        except OSError as e:
            logger.debug(f"Could not read /etc/localtime symlink: {e}")

    return "UTC"


def create_env_file(
    config_dir: Path,
    api_key: str,
    profile_id: str,
) -> Path:
    """
    Create .env file with API credentials.

    Args:
        config_dir: Directory to create .env in
        api_key: NextDNS API key
        profile_id: NextDNS profile ID

    Returns:
        Path to created .env file
    """
    config_dir.mkdir(parents=True, exist_ok=True)

    env_file = config_dir / ".env"

    content = f"""# NextDNS Blocker Configuration
# Generated by 'nextdns-blocker init'

# NextDNS API credentials (required)
NEXTDNS_API_KEY={api_key}
NEXTDNS_PROFILE_ID={profile_id}
"""

    # Write with secure permissions (0o600)
    write_secure_file(env_file, content)

    return env_file


def create_default_config_in_db(timezone: str) -> None:
    """
    Seed the database with default settings (timezone, empty notifications).
    Marks config as migrated so load_domains considers the DB initialized.
    """
    from . import database as db

    db.init_database()
    db.set_config("version", "1.0")
    db.set_config("settings", {"timezone": timezone, "editor": None})
    db.set_config("notifications", {})
    db.set_config("protection", {})
    db.set_config("parental_control", {})
    db.set_config("migrated", True)


# =============================================================================
# SCHEDULING INSTALLATION
# =============================================================================


def install_scheduling() -> tuple[bool, str]:
    """
    Install scheduling jobs by delegating to the watchdog module.

    Uses the watchdog's platform-specific installers (launchd/systemd/cron/Task Scheduler).

    Returns:
        Tuple of (success, message)
    """
    from .watchdog import (
        _install_cron_jobs,
        _install_launchd_jobs,
        _install_systemd_timers,
        _install_windows_tasks,
    )

    try:
        if is_macos():
            _install_launchd_jobs()
            return True, "launchd"
        elif is_windows():
            _install_windows_tasks()
            return True, "Task Scheduler"
        elif has_systemd():
            _install_systemd_timers()
            return True, "systemd"
        else:
            _install_cron_jobs()
            return True, "cron"
    except SystemExit:
        return False, "failed to install scheduled jobs"
    except (OSError, subprocess.SubprocessError) as e:
        logger.error(f"Failed to install scheduling: {e}")
        return False, f"failed to install scheduling: {e}"


def run_initial_sync() -> bool:
    """Run initial config push command."""
    try:
        exe_args = get_executable_args()
        result = subprocess.run(
            exe_args + ["config", "push"],
            capture_output=True,
            text=True,
            timeout=60,
        )
        return result.returncode == 0
    except subprocess.TimeoutExpired:
        logger.warning("Initial sync timed out after 60 seconds")
        return False
    except OSError as e:
        logger.warning(f"Initial sync failed: {e}")
        return False


def run_interactive_wizard(config_dir_override: Optional[Path] = None) -> bool:
    """
    Run the interactive setup wizard.

    Args:
        config_dir_override: Optional config directory override

    Returns:
        True if setup completed successfully
    """
    click.echo()
    click.echo(click.style("  NextDNS Blocker Setup", fg="cyan", bold=True))
    click.echo(click.style("  " + "=" * 21, fg="cyan"))
    click.echo()

    # Prompt for API key
    api_key = click.prompt("  API Key (from https://my.nextdns.io/account)", hide_input=True)

    if not api_key or not api_key.strip():
        click.echo(click.style("\n  Error: API key is required\n", fg="red"))
        return False

    api_key = api_key.strip()

    # Prompt for Profile ID
    profile_id = click.prompt("  Profile ID (from URL my.nextdns.io/<profile_id>)")

    if not profile_id or not profile_id.strip():
        click.echo(click.style("\n  Error: Profile ID is required\n", fg="red"))
        return False

    profile_id = profile_id.strip()

    # Validate credentials
    click.echo()
    click.echo("  Validating credentials... ", nl=False)

    valid, msg = validate_api_credentials(api_key, profile_id)

    if valid:
        click.echo(click.style("OK", fg="green"))
    else:
        click.echo(click.style("FAILED", fg="red"))
        click.echo(click.style(f"\n  Error: {msg}\n", fg="red"))
        return False

    # Determine config directory
    config_dir = get_config_dir(config_dir_override)

    # Auto-detect timezone
    timezone = detect_system_timezone()
    click.echo(f"  Timezone detected: {timezone}")

    # Create .env file (credentials only)
    click.echo()
    env_file = create_env_file(config_dir, api_key, profile_id)
    click.echo(f"  Created: {env_file}")

    # Seed database with default settings if not already migrated
    from . import database as db

    if not db.config_has_domains():
        create_default_config_in_db(timezone)
        click.echo("  Database initialized with default settings")
    else:
        click.echo("  Database already has configuration")

    # Install scheduling (launchd/cron)
    click.echo()
    click.echo("  Installing scheduling...")
    sched_success, sched_type = install_scheduling()

    if sched_success:
        click.echo(click.style(f"  {sched_type} jobs installed", fg="green"))
        click.echo("    sync:      every 2 min")
        click.echo("    watchdog:  every 1 min")
    else:
        click.echo(click.style(f"  Warning: {sched_type}", fg="yellow"))
        click.echo("  You can install manually with: nextdns-blocker watchdog install")

    # Run initial sync
    click.echo()
    click.echo("  Running initial sync... ", nl=False)
    if run_initial_sync():
        click.echo(click.style("OK", fg="green"))
    else:
        click.echo(click.style("FAILED", fg="yellow"))
        click.echo("  You can run manually: nextdns-blocker sync")

    # Install shell completion
    shell = detect_shell()
    if shell and not is_windows():
        click.echo()
        click.echo("  Installing shell completion... ", nl=False)
        success, msg = install_completion(shell)
        if success:
            if "Already" in msg:
                click.echo(click.style("OK", fg="green") + " (already installed)")
            else:
                click.echo(click.style("OK", fg="green"))
                click.echo(f"    {msg}")
                click.echo(
                    f"    Restart your shell or run: source ~/{'.zshrc' if shell == 'zsh' else '.bashrc'}"
                )
        else:
            click.echo(click.style("SKIPPED", fg="yellow"))
            click.echo(f"    {msg}")
            click.echo("    You can install manually: nextdns-blocker completion --help")

    # Success message
    click.echo()
    click.echo(click.style("  Setup complete!", fg="green", bold=True))
    click.echo()
    click.echo("  Next steps:")
    click.echo("    nextdns-blocker config edit  - Add domains to block")
    click.echo()
    click.echo("  Commands:")
    click.echo("    nextdns-blocker status    - Show blocking status")
    click.echo("    nextdns-blocker sync      - Manual sync")
    click.echo("    nextdns-blocker pause 30  - Pause for 30 min")
    click.echo("    nextdns-blocker health    - Health check")
    click.echo()
    click.echo("  Logs:")
    click.echo(f"    {get_log_dir()}")
    click.echo()
    if is_macos():
        click.echo("  launchd:")
        click.echo("    launchctl list | grep nextdns")
        click.echo()
    elif is_windows():
        click.echo("  Task Scheduler:")
        click.echo("    schtasks /query /tn NextDNS-Blocker-Sync")
        click.echo("    schtasks /query /tn NextDNS-Blocker-Watchdog")
        click.echo()
    else:
        click.echo("  cron:")
        click.echo("    crontab -l | grep nextdns")
        click.echo()

    return True


def run_non_interactive(config_dir_override: Optional[Path] = None) -> bool:
    """
    Run non-interactive setup using environment variables.

    Expects:
        NEXTDNS_API_KEY: API key
        NEXTDNS_PROFILE_ID: Profile ID

    Args:
        config_dir_override: Optional config directory override

    Returns:
        True if setup completed successfully
    """
    api_key = os.environ.get("NEXTDNS_API_KEY")
    profile_id = os.environ.get("NEXTDNS_PROFILE_ID")

    if not api_key:
        click.echo("Error: NEXTDNS_API_KEY environment variable not set", err=True)
        return False

    if not profile_id:
        click.echo("Error: NEXTDNS_PROFILE_ID environment variable not set", err=True)
        return False

    # Validate credentials
    valid, msg = validate_api_credentials(api_key, profile_id)
    if not valid:
        click.echo(f"Error: {msg}", err=True)
        return False

    # Determine config directory
    config_dir = get_config_dir(config_dir_override)

    # Auto-detect timezone
    timezone = detect_system_timezone()

    # Create .env file (credentials only)
    env_file = create_env_file(config_dir, api_key, profile_id)
    click.echo(f"Configuration saved to: {env_file}")

    from . import database as db

    if not db.config_has_domains():
        create_default_config_in_db(timezone)
        click.echo("Database initialized with default settings")

    # Install scheduling
    sched_success, sched_type = install_scheduling()
    if sched_success:
        click.echo(f"Scheduling installed ({sched_type})")
    else:
        click.echo(f"Warning: {sched_type}", err=True)

    # Run initial sync
    if run_initial_sync():
        click.echo("Initial sync completed")
    else:
        click.echo("Warning: Initial sync failed", err=True)

    return True
